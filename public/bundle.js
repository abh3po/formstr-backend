/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";const t="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function e(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function n(t,...e){if(!((n=t)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function r(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function o(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function i(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function s(t,e){return t<<32-e|t>>>e}const a=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),f=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function c(t){if(n(t),a)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=f[t[n]];return e}function u(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),n(t),t}class l{}function h(t){const e=e=>t().update(u(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function d(e=32){if(t&&"function"==typeof t.getRandomValues)return t.getRandomValues(new Uint8Array(e));if(t&&"function"==typeof t.randomBytes)return Uint8Array.from(t.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}function g(t,e,n){return t&e^t&n^e&n}class w extends l{constructor(t,e,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(t),this.view=i(this.buffer)}update(t){r(this),n(t=u(t));const{view:e,buffer:o,blockLen:s}=this,a=t.length;for(let n=0;n<a;){const r=Math.min(s-this.pos,a-n);if(r!==s)o.set(t.subarray(n,n+r),this.pos),this.pos+=r,n+=r,this.pos===s&&(this.process(e,0),this.pos=0);else{const e=i(t);for(;s<=a-n;n+=s)this.process(e,n)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){r(this),function(t,e){n(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(t,this),this.finished=!0;const{buffer:e,view:s,blockLen:a,isLE:f}=this;let{pos:c}=this;e[c++]=128,o(this.buffer.subarray(c)),this.padOffset>a-c&&(this.process(s,0),c=0);for(let t=c;t<a;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),a=Number(n&i),f=r?4:0,c=r?0:4;t.setUint32(e+f,s,r),t.setUint32(e+c,a,r)}(s,a-8,BigInt(8*this.length),f),this.process(s,0);const u=i(t),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=l/4,d=this.get();if(h>d.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)u.setUint32(4*t,d[t],f)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return t.destroyed=i,t.finished=o,t.length=r,t.pos=s,r%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const p=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),y=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),m=new Uint32Array(64);class E extends w{constructor(t=32){super(64,t,8,!1),this.A=0|p[0],this.B=0|p[1],this.C=0|p[2],this.D=0|p[3],this.E=0|p[4],this.F=0|p[5],this.G=0|p[6],this.H=0|p[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:i,G:s,H:a}=this;return[t,e,n,r,o,i,s,a]}set(t,e,n,r,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let n=0;n<16;n++,e+=4)m[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=m[t-15],n=m[t-2],r=s(e,7)^s(e,18)^e>>>3,o=s(n,17)^s(n,19)^n>>>10;m[t]=o+m[t-7]+r+m[t-16]|0}let{A:n,B:r,C:o,D:i,E:a,F:f,G:c,H:u}=this;for(let t=0;t<64;t++){const e=u+(s(a,6)^s(a,11)^s(a,25))+((l=a)&f^~l&c)+y[t]+m[t]|0,h=(s(n,2)^s(n,13)^s(n,22))+g(n,r,o)|0;u=c,c=f,f=a,a=i+e|0,i=o,o=r,r=n,n=e+h|0}var l;n=n+this.A|0,r=r+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,f=f+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(n,r,o,i,a,f,c,u)}roundClean(){o(m)}destroy(){this.set(0,0,0,0,0,0,0,0),o(this.buffer)}}const b=h((()=>new E));class B extends l{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");e(t.outputLen),e(t.blockLen)}(t);const r=u(n);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),o(s)}update(t){return r(this),this.iHash.update(t),this}digestInto(t){r(this),n(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=r,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const v=(t,e,n)=>new B(t,e).update(n).digest();v.create=(t,e)=>new B(t,e);const x=BigInt(0),A=BigInt(1);function S(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function I(t){if(!S(t))throw new Error("Uint8Array expected")}function O(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}function N(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function R(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?x:BigInt("0x"+t)}const q="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,L=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function U(t){if(I(t),q)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=L[t[n]];return e}function H(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function k(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(q)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=H(t.charCodeAt(o)),i=H(t.charCodeAt(o+1));if(void 0===n||void 0===i){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+i}return r}function P(t){return R(U(t))}function C(t){return I(t),R(U(Uint8Array.from(t).reverse()))}function z(t,e){return k(t.toString(16).padStart(2*e,"0"))}function F(t,e){return z(t,e).reverse()}function T(t,e,n){let r;if("string"==typeof e)try{r=k(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!S(e))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}function Z(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];I(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}const V=t=>"bigint"==typeof t&&x<=t;function K(t,e,n){return V(t)&&V(e)&&V(n)&&e<=t&&t<n}function j(t,e,n,r){if(!K(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}const D=t=>(A<<BigInt(t))-A,_=t=>new Uint8Array(t),Y=t=>Uint8Array.from(t),G={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||S(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function M(t,e,n={}){const r=(e,n,r)=>{const o=G[n];if("function"!=typeof o)throw new Error("invalid validator function");const i=t[e];if(!(r&&void 0===i||o(i,t)))throw new Error("param "+String(e)+" is invalid. Expected "+n+", got "+i)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}function W(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const i=t(n,...r);return e.set(n,i),i}}const J=BigInt(0),$=BigInt(1),Q=BigInt(2),X=BigInt(3),tt=BigInt(4),et=BigInt(5),nt=BigInt(8);function rt(t,e){const n=t%e;return n>=J?n:e+n}function ot(t,e,n){let r=t;for(;e-- >J;)r*=r,r%=n;return r}function it(t,e){if(t===J)throw new Error("invert: expected non-zero number");if(e<=J)throw new Error("invert: expected positive modulus, got "+e);let n=rt(t,e),r=e,o=J,i=$,s=$,a=J;for(;n!==J;){const t=r/n,e=r%n,f=o-s*t,c=i-a*t;r=n,n=e,o=s,i=a,s=f,a=c}if(r!==$)throw new Error("invert: does not exist");return rt(o,e)}const st=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function at(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),o=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),i=t.inv(o);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),i),r}function ft(t,e){const n=function(t,e){const n=(t.ORDER-$)/Q,r=t.pow(e,n),o=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),s=t.eql(r,t.neg(t.ONE));if(!o&&!i&&!s)throw new Error("Cannot find square root: probably non-prime P");return o?1:i?0:-1}(t,e);return 0===n||1===n}function ct(t,n){void 0!==n&&e(n);const r=void 0!==n?n:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function ut(t,e,n=!1,r={}){if(t<=J)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=ct(t,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const a=Object.freeze({ORDER:t,isLE:n,BITS:o,BYTES:i,MASK:D(o),ZERO:J,ONE:$,create:e=>rt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return J<=e&&e<t},is0:t=>t===J,isOdd:t=>(t&$)===$,neg:e=>rt(-e,t),eql:(t,e)=>t===e,sqr:e=>rt(e*e,t),add:(e,n)=>rt(e+n,t),sub:(e,n)=>rt(e-n,t),mul:(e,n)=>rt(e*n,t),pow:(t,e)=>function(t,e,n){if(n<J)throw new Error("invalid exponent, negatives unsupported");if(n===J)return t.ONE;if(n===$)return e;let r=t.ONE,o=e;for(;n>J;)n&$&&(r=t.mul(r,o)),o=t.sqr(o),n>>=$;return r}(a,t,e),div:(e,n)=>rt(e*it(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>it(e,t),sqrt:r.sqrt||(e=>{return s||(s=(n=t)%tt===X?function(t,e){const r=(n+$)/tt,o=t.pow(e,r);if(!t.eql(t.sqr(o),e))throw new Error("Cannot find square root");return o}:n%nt===et?function(t,e){const r=t.mul(e,Q),o=(n-et)/nt,i=t.pow(r,o),s=t.mul(e,i),a=t.mul(t.mul(s,Q),i),f=t.mul(s,t.sub(a,t.ONE));if(!t.eql(t.sqr(f),e))throw new Error("Cannot find square root");return f}:function(t){let e=t-$,n=0;for(;e%Q===J;)e/=Q,n++;let r=Q;const o=ut(t);for(;r<t&&ft(o,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n){const e=(t+$)/tt;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const i=(e+$)/Q;return function(t,o){if(!ft(t,o))throw new Error("Cannot find square root");let s=n,a=t.pow(t.mul(t.ONE,r),e),f=t.pow(o,i),c=t.pow(o,e);for(;!t.eql(c,t.ONE);){if(t.eql(c,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(c);e<s&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(a,$<<BigInt(s-e-1));a=t.sqr(n),f=t.mul(f,n),c=t.mul(c,a),s=e}return f}}(n)),s(a,e);var n}),toBytes:t=>n?F(t,i):z(t,i),fromBytes:t=>{if(t.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+t.length);return n?C(t):P(t)},invertBatch:t=>at(a,t),cmov:(t,e,n)=>n?e:t});return Object.freeze(a)}function lt(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function ht(t){const e=lt(t);return e+Math.ceil(e/2)}const dt=BigInt(0),gt=BigInt(1);function wt(t,e){const n=e.negate();return t?n:e}function pt(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function yt(t,e){pt(t,e);const n=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:D(t),maxNumber:n,shiftBy:BigInt(t)}}function mt(t,e,n){const{windowSize:r,mask:o,maxNumber:i,shiftBy:s}=n;let a=Number(t&o),f=t>>s;a>r&&(a-=i,f+=gt);const c=e*r;return{nextN:f,offset:c+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:c}}const Et=new WeakMap,bt=new WeakMap;function Bt(t){return bt.get(t)||1}function vt(t,e,n,r){if(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach(((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)}))}(n,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach(((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)}))}(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=function(t){let e;for(e=0;t>x;t>>=A,e+=1);return e}(BigInt(n.length)),s=i>12?i-3:i>4?i-2:i?2:1,a=D(s),f=new Array(Number(a)+1).fill(o);let c=o;for(let t=Math.floor((e.BITS-1)/s)*s;t>=0;t-=s){f.fill(o);for(let e=0;e<r.length;e++){const o=r[e],i=Number(o>>BigInt(t)&a);f[i]=f[i].add(n[e])}let e=o;for(let t=f.length-1,n=o;t>0;t--)n=n.add(f[t]),e=e.add(n);if(c=c.add(e),0!==t)for(let t=0;t<s;t++)c=c.double()}return c}function xt(t){return M(t.Fp,st.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),M(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ct(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function At(t){void 0!==t.lowS&&O("lowS",t.lowS),void 0!==t.prehash&&O("prehash",t.prehash)}class St extends Error{constructor(t=""){super(t)}}const It={Err:St,_tlv:{encode:(t,e)=>{const{Err:n}=It;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=N(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?N(o.length/2|128):"";return N(t)+i+o+e},decode(t,e){const{Err:n}=It;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];let i=0;if(128&o){const t=127&o;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const s=e.subarray(r,r+t);if(s.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===s[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of s)i=i<<8|t;if(r+=t,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=o;const s=e.subarray(r,r+i);if(s.length!==i)throw new n("tlv.decode: wrong value length");return{v:s,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=It;if(t<Ot)throw new e("integer: negative integers are not allowed");let n=N(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=It;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return P(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=It,o=T("signature",t),{v:i,l:s}=r.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:f}=r.decode(2,i),{v:c,l:u}=r.decode(2,f);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(c)}},hexFromSig(t){const{_tlv:e,_int:n}=It,r=e.encode(2,n.encode(t.r))+e.encode(2,n.encode(t.s));return e.encode(48,r)}},Ot=BigInt(0),Nt=BigInt(1),Rt=(BigInt(2),BigInt(3));function qt(t){const e=function(t){const e=xt(t);return M(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function s(t){return rt(t,r)}function a(t){return it(t,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:c,weierstrassEquation:u,isWithinCurveOrder:l}=function(t){const e=function(t){const e=xt(t);M(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=ut(e.n,e.nBitLength),o=e.toBytes||((t,e,r)=>{const o=e.toAffine();return Z(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function s(t){const{a:r,b:o}=e,i=n.sqr(t),s=n.mul(i,t);return n.add(n.add(s,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function a(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:o,n:i}=e;if(n&&"bigint"!=typeof t){if(S(t)&&(t=U(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*r,"0")}let s;try{s="bigint"==typeof t?t:P(T("private key",t,r))}catch(e){throw new Error("invalid private key, expected hex or "+r+" bytes, got "+typeof t)}return o&&(s=rt(s,i)),j("private key",s,Nt,i),s}function f(t){if(!(t instanceof l))throw new Error("ProjectivePoint expected")}const c=W(((t,e)=>{const{px:r,py:o,pz:i}=t;if(n.eql(i,n.ONE))return{x:r,y:o};const s=t.is0();null==e&&(e=s?n.ONE:n.inv(i));const a=n.mul(r,e),f=n.mul(o,e),c=n.mul(i,e);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw new Error("invZ was invalid");return{x:a,y:f}})),u=W((t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=t.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not FE");const i=n.sqr(o),a=s(r);if(!n.eql(i,a))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class l{constructor(t,e,r){if(null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e)||n.is0(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");this.px=t,this.py=e,this.pz=r,Object.freeze(this)}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof l)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?l.ZERO:new l(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=at(n,t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(l.fromAffine)}static fromHex(t){const e=l.fromAffine(i(T("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return l.BASE.multiply(a(t))}static msm(t,e){return vt(l,r,t,e)}_setWindowSize(t){d.setWindowSize(this,t)}assertValidity(){u(this)}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){f(t);const{px:e,py:r,pz:o}=this,{px:i,py:s,pz:a}=t,c=n.eql(n.mul(e,a),n.mul(i,o)),u=n.eql(n.mul(r,a),n.mul(s,o));return c&&u}negate(){return new l(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,Rt),{px:i,py:s,pz:a}=this;let f=n.ZERO,c=n.ZERO,u=n.ZERO,h=n.mul(i,i),d=n.mul(s,s),g=n.mul(a,a),w=n.mul(i,s);return w=n.add(w,w),u=n.mul(i,a),u=n.add(u,u),f=n.mul(t,u),c=n.mul(o,g),c=n.add(f,c),f=n.sub(d,c),c=n.add(d,c),c=n.mul(f,c),f=n.mul(w,f),u=n.mul(o,u),g=n.mul(t,g),w=n.sub(h,g),w=n.mul(t,w),w=n.add(w,u),u=n.add(h,h),h=n.add(u,h),h=n.add(h,g),h=n.mul(h,w),c=n.add(c,h),g=n.mul(s,a),g=n.add(g,g),h=n.mul(g,w),f=n.sub(f,h),u=n.mul(g,d),u=n.add(u,u),u=n.add(u,u),new l(f,c,u)}add(t){f(t);const{px:r,py:o,pz:i}=this,{px:s,py:a,pz:c}=t;let u=n.ZERO,h=n.ZERO,d=n.ZERO;const g=e.a,w=n.mul(e.b,Rt);let p=n.mul(r,s),y=n.mul(o,a),m=n.mul(i,c),E=n.add(r,o),b=n.add(s,a);E=n.mul(E,b),b=n.add(p,y),E=n.sub(E,b),b=n.add(r,i);let B=n.add(s,c);return b=n.mul(b,B),B=n.add(p,m),b=n.sub(b,B),B=n.add(o,i),u=n.add(a,c),B=n.mul(B,u),u=n.add(y,m),B=n.sub(B,u),d=n.mul(g,b),u=n.mul(w,m),d=n.add(u,d),u=n.sub(y,d),d=n.add(y,d),h=n.mul(u,d),y=n.add(p,p),y=n.add(y,p),m=n.mul(g,m),b=n.mul(w,b),y=n.add(y,m),m=n.sub(p,m),m=n.mul(g,m),b=n.add(b,m),p=n.mul(y,b),h=n.add(h,p),p=n.mul(B,b),u=n.mul(E,u),u=n.sub(u,p),p=n.mul(E,y),d=n.mul(B,d),d=n.add(d,p),new l(u,h,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(l.ZERO)}wNAF(t){return d.wNAFCached(this,t,l.normalizeZ)}multiplyUnsafe(t){const{endo:r,n:o}=e;j("scalar",t,Ot,o);const i=l.ZERO;if(t===Ot)return i;if(this.is0()||t===Nt)return this;if(!r||d.hasPrecomputes(this))return d.wNAFCachedUnsafe(this,t,l.normalizeZ);let{k1neg:s,k1:a,k2neg:f,k2:c}=r.splitScalar(t),u=i,h=i,g=this;for(;a>Ot||c>Ot;)a&Nt&&(u=u.add(g)),c&Nt&&(h=h.add(g)),g=g.double(),a>>=Nt,c>>=Nt;return s&&(u=u.negate()),f&&(h=h.negate()),h=new l(n.mul(h.px,r.beta),h.py,h.pz),u.add(h)}multiply(t){const{endo:r,n:o}=e;let i,s;if(j("scalar",t,Nt,o),r){const{k1neg:e,k1:o,k2neg:a,k2:f}=r.splitScalar(t);let{p:c,f:u}=this.wNAF(o),{p:h,f:g}=this.wNAF(f);c=d.constTimeNegate(e,c),h=d.constTimeNegate(a,h),h=new l(n.mul(h.px,r.beta),h.py,h.pz),i=c.add(h),s=u.add(g)}else{const{p:e,f:n}=this.wNAF(t);i=e,s=n}return l.normalizeZ([i,s])[0]}multiplyAndAddUnsafe(t,e,n){const r=l.BASE,o=(t,e)=>e!==Ot&&e!==Nt&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,n));return i.is0()?void 0:i}toAffine(t){return c(this,t)}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===Nt)return!0;if(n)return n(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===Nt?this:n?n(l,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return O("isCompressed",t),this.assertValidity(),o(l,this,t)}toHex(t=!0){return O("isCompressed",t),U(this.toRawBytes(t))}}l.BASE=new l(e.Gx,e.Gy,n.ONE),l.ZERO=new l(n.ZERO,n.ONE,n.ZERO);const h=e.nBitLength,d=(g=l,w=e.endo?Math.ceil(h/2):h,{constTimeNegate:wt,hasPrecomputes:t=>1!==Bt(t),unsafeLadder(t,e,n=g.ZERO){let r=t;for(;e>dt;)e&gt&&(n=n.add(r)),r=r.double(),e>>=gt;return n},precomputeWindow(t,e){const{windows:n,windowSize:r}=yt(e,w),o=[];let i=t,s=i;for(let t=0;t<n;t++){s=i,o.push(s);for(let t=1;t<r;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(t,e,n){let r=g.ZERO,o=g.BASE;const i=yt(t,w);for(let t=0;t<i.windows;t++){const{nextN:s,offset:a,isZero:f,isNeg:c,isNegF:u,offsetF:l}=mt(n,t,i);n=s,f?o=o.add(wt(u,e[l])):r=r.add(wt(c,e[a]))}return{p:r,f:o}},wNAFUnsafe(t,e,n,r=g.ZERO){const o=yt(t,w);for(let t=0;t<o.windows&&n!==dt;t++){const{nextN:i,offset:s,isZero:a,isNeg:f}=mt(n,t,o);if(n=i,!a){const t=e[s];r=r.add(f?t.negate():t)}}return r},getPrecomputes(t,e,n){let r=Et.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&Et.set(e,n(r))),r},wNAFCached(t,e,n){const r=Bt(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)},wNAFCachedUnsafe(t,e,n,r){const o=Bt(t);return 1===o?this.unsafeLadder(t,e,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)},setWindowSize(t,e){pt(e,w),bt.set(t,e),Et.delete(t)}});var g,w;return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder:function(t){return K(t,Nt,e.n)}}}({...e,toBytes(t,e,r){const o=e.toAffine(),i=n.toBytes(o.x),s=Z;return O("isCompressed",r),r?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],s=t.subarray(1);if(e!==o||2!==r&&3!==r){if(e===i&&4===r)return{x:n.fromBytes(s.subarray(0,n.BYTES)),y:n.fromBytes(s.subarray(n.BYTES,2*n.BYTES))};throw new Error("invalid Point, expected length of "+o+", or uncompressed "+i+", got "+e)}{const t=P(s);if(!K(t,Nt,n.ORDER))throw new Error("Point is not on curve");const e=u(t);let o;try{o=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~r)!=((o&Nt)===Nt)&&(o=n.neg(o)),{x:t,y:o}}}}),h=t=>U(z(t,e.nByteLength));function d(t){return t>r>>Nt}const g=(t,e,n)=>P(t.slice(e,n));class w{constructor(t,e,n){j("r",t,Nt,r),j("s",e,Nt,r),this.r=t,this.s=e,null!=n&&(this.recovery=n),Object.freeze(this)}static fromCompact(t){const n=e.nByteLength;return t=T("compactSignature",t,2*n),new w(g(t,0,n),g(t,n,2*n))}static fromDER(t){const{r:e,s:n}=It.toSig(T("DER",t));return new w(e,n)}assertValidity(){}addRecoveryBit(t){return new w(this.r,this.s,t)}recoverPublicKey(t){const{r,s:o,recovery:i}=this,c=E(T("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?r+e.n:r;if(u>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=1&i?"03":"02",d=f.fromHex(l+h(u)),g=a(u),w=s(-c*g),p=s(o*g),y=f.BASE.multiplyAndAddUnsafe(d,w,p);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return k(this.toDERHex())}toDERHex(){return It.hexFromSig(this)}toCompactRawBytes(){return k(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const p={isValidPrivateKey(t){try{return c(t),!0}catch(t){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const t=ht(e.n);return function(t,e,n=!1){const r=t.length,o=lt(e),i=ht(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const s=rt(n?C(t):P(t),e-$)+$;return n?F(s,o):z(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=f.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function y(t){const e=S(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===o||r===i:n?r===2*o||r===2*i:t instanceof f}const m=e.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const n=P(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},E=e.bits2int_modN||function(t){return s(m(t))},b=D(e.nBitLength);function B(t){return j("num < 2^"+e.nBitLength,t,Ot,b),z(t,e.nByteLength)}const v={lowS:e.lowS,prehash:!1},x={lowS:e.lowS,prehash:!1};return f.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return f.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(y(t))throw new Error("first arg must be private key");if(!y(e))throw new Error("second arg must be public key");return f.fromHex(e).multiply(c(t)).toRawBytes(n)},sign:function(t,r,o=v){const{seed:i,k2sig:u}=function(t,r,o=v){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=e;let{lowS:h,prehash:g,extraEntropy:p}=o;null==h&&(h=!0),t=T("msgHash",t),At(o),g&&(t=T("prehashed msgHash",i(t)));const y=E(t),b=c(r),x=[B(b),B(y)];if(null!=p&&!1!==p){const t=!0===p?u(n.BYTES):p;x.push(T("extraEntropy",t))}const A=Z(...x),S=y;return{seed:A,k2sig:function(t){const e=m(t);if(!l(e))return;const n=a(e),r=f.BASE.multiply(e).toAffine(),o=s(r.x);if(o===Ot)return;const i=s(n*s(S+o*b));if(i===Ot)return;let c=(r.x===o?0:2)|Number(r.y&Nt),u=i;return h&&d(i)&&(u=function(t){return d(t)?s(-t):t}(i),c^=1),new w(o,u,c)}}}(t,r,o),h=e;return function(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=_(t),o=_(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},a=(...t)=>n(o,r,...t),f=(t=_(0))=>{o=a(Y([0]),t),r=a(),0!==t.length&&(o=a(Y([1]),t),r=a())},c=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=a();const e=r.slice();n.push(e),t+=r.length}return Z(...n)};return(t,e)=>{let n;for(s(),f(t);!(n=e(c()));)f();return s(),n}}(h.hash.outputLen,h.nByteLength,h.hmac)(i,u)},verify:function(t,n,r,o=x){const i=t;n=T("msgHash",n),r=T("publicKey",r);const{lowS:c,prehash:u,format:l}=o;if(At(o),"strict"in o)throw new Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw new Error("format must be compact or der");const h="string"==typeof i||S(i),d=!h&&!l&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!h&&!d)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,p;try{if(d&&(g=new w(i.r,i.s)),h){try{"compact"!==l&&(g=w.fromDER(i))}catch(t){if(!(t instanceof It.Err))throw t}g||"der"===l||(g=w.fromCompact(i))}p=f.fromHex(r)}catch(t){return!1}if(!g)return!1;if(c&&g.hasHighS())return!1;u&&(n=e.hash(n));const{r:y,s:m}=g,b=E(n),B=a(m),v=s(b*B),A=s(y*B),I=f.BASE.multiplyAndAddUnsafe(p,v,A)?.toAffine();return!!I&&s(I.x)===y},ProjectivePoint:f,Signature:w,utils:p}}function Lt(t){return{hash:t,hmac:(e,...r)=>v(t,e,function(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];n(o),e+=o.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}(...r)),randomBytes:d}}BigInt(4);const Ut=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ht=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),kt=BigInt(1),Pt=BigInt(2),Ct=(t,e)=>(t+e/Pt)/e;function zt(t){const e=Ut,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),f=BigInt(88),c=t*t*t%e,u=c*c*t%e,l=ot(u,n,e)*u%e,h=ot(l,n,e)*u%e,d=ot(h,Pt,e)*c%e,g=ot(d,o,e)*d%e,w=ot(g,i,e)*g%e,p=ot(w,a,e)*w%e,y=ot(p,f,e)*p%e,m=ot(y,a,e)*w%e,E=ot(m,n,e)*u%e,b=ot(E,s,e)*g%e,B=ot(b,r,e)*c%e,v=ot(B,Pt,e);if(!Ft.eql(Ft.sqr(v),t))throw new Error("Cannot find square root");return v}const Ft=ut(Ut,void 0,void 0,{sqrt:zt}),Tt=function(t,e){const n=e=>qt({...t,...Lt(e)});return{...n(e),create:n}}({a:BigInt(0),b:BigInt(7),Fp:Ft,n:Ht,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Ht,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-kt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,s=BigInt("0x100000000000000000000000000000000"),a=Ct(i*t,e),f=Ct(-r*t,e);let c=rt(t-a*n-f*o,e),u=rt(-a*r-f*i,e);const l=c>s,h=u>s;if(l&&(c=e-c),h&&(u=e-u),c>s||u>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:c,k2neg:h,k2:u}}}},b),Zt=BigInt(0),Vt={};function Kt(t,...e){let n=Vt[t];if(void 0===n){const e=b(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=Z(e,e),Vt[t]=n}return b(Z(n,...e))}const jt=t=>t.toRawBytes(!0).slice(1),Dt=t=>z(t,32),_t=t=>rt(t,Ut),Yt=t=>rt(t,Ht),Gt=Tt.ProjectivePoint;function Mt(t){let e=Tt.utils.normPrivateKeyToScalar(t),n=Gt.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:Yt(-e),bytes:jt(n)}}function Wt(t){j("x",t,kt,Ut);const e=_t(t*t);let n=zt(_t(e*t+BigInt(7)));n%Pt!==Zt&&(n=_t(-n));const r=new Gt(t,n,kt);return r.assertValidity(),r}const Jt=P;function $t(...t){return Yt(Jt(Kt("BIP0340/challenge",...t)))}function Qt(t){return Mt(t).bytes}function Xt(t,e,n=d(32)){const r=T("message",t),{bytes:o,scalar:i}=Mt(e),s=T("auxRand",n,32),a=Dt(i^Jt(Kt("BIP0340/aux",s))),f=Kt("BIP0340/nonce",a,o,r),c=Yt(Jt(f));if(c===Zt)throw new Error("sign failed: k is zero");const{bytes:u,scalar:l}=Mt(c),h=$t(u,o,r),g=new Uint8Array(64);if(g.set(u,0),g.set(Dt(Yt(l+h*i)),32),!te(g,r,o))throw new Error("sign: Invalid signature produced");return g}function te(t,e,n){const r=T("signature",t,64),o=T("message",e),i=T("publicKey",n,32);try{const t=Wt(Jt(i)),e=Jt(r.subarray(0,32));if(!K(e,kt,Ut))return!1;const n=Jt(r.subarray(32,64));if(!K(n,kt,Ht))return!1;const c=$t(Dt(e),jt(t),o),u=(s=t,a=n,f=Yt(-c),Gt.BASE.multiplyAndAddUnsafe(s,a,f));return!(!u||!u.hasEvenY()||u.toAffine().x!==e)}catch(t){return!1}var s,a,f}const ee=(()=>({getPublicKey:Qt,sign:Xt,verify:te,utils:{randomPrivateKey:Tt.utils.randomPrivateKey,lift_x:Wt,pointToBytes:jt,numberToBytesBE:z,bytesToNumberBE:P,taggedHash:Kt,mod:rt}}))(),ne=b;document.getElementById("createButton").addEventListener("click",(async function(){const t=document.getElementById("createName").value,e=document.getElementById("createUrl").value,n=document.getElementById("privateKey").value,r=document.getElementById("response");if(t&&e&&n)try{const o=await async function(t,e,n,r=null){const o=c(ee.getPublicKey(t)),i=Math.floor(Date.now()/1e3),s=[["u",n],["method",e]];if(r){const t=c(ne(JSON.stringify(r)));s.push(["payload",t])}const a={pubkey:o,created_at:i,kind:27235,tags:s,content:""},f=JSON.stringify([0,o,i,27235,s,""]),u=c(ne(f));return{...a,id:u,sig:c(ee.sign(u,t))}}(n,"POST","http://localhost:5000/api/shortlink",{name:t,url:e}),i=await fetch("/api/shortlink",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Nostr ${btoa(JSON.stringify(o))}`},body:JSON.stringify({name:t,url:e})}),s=await i.json();r.textContent=JSON.stringify(s,null,2)}catch(t){r.textContent=`Error: ${t.message}`}else r.textContent="Error: All fields are required for creating a short link."})),document.getElementById("getButton").addEventListener("click",(async function(){const t=document.getElementById("getName").value,e=document.getElementById("response");if(t)try{const n=await fetch(`/api/shortlink/${t}`,{method:"GET"}),r=await n.json();e.textContent=JSON.stringify(r,null,2)}catch(t){e.textContent=`Error: ${t.message}`}else e.textContent="Error: Short name is required."}))})();